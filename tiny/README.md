# tiny
A toy URL shortener implementation.

# Design
Use cases:
* Lookup an entry
* Create a new random entry
* Create a new named ent

Non goals:
* Non-random paths
* Ownership (i.e. list my entries)
* Delete entries
* Analytics on entries
* TTL for unused entries
* Support multiple domains (though the design could...)

An implementation of the commonly suggested twist to "design a URL shortener"
interview questions. Stores up to ~3.5 trillion shortened URLs within a 7 char
namespace in which short paths are generated by base62 encoding an integer.

Having several backends competing to read and update a shared, strongly
consistent, counter (i.e. the next available URL) in some storage layer seemed
inefficient. I'm curious to explore reducing the contention by sharding the
URL namespace across multiple database and having a loadbalancing layer that
knows which shards own which short path ranges.

# TODO
* A real datastore - probably Dynamo or Datastore.
* Logging! Who knows if this even works?!
* Implement ingress layer - i.e. thing what does loadbalancing and sharding.
